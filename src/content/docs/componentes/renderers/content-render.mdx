---
title: ContentRender
description: Componente para listar contenido con caché, paginación y plantillas callback
sidebar:
  order: 1
---

## Resumen
Componente agnóstico para renderizar listados de posts con caché de fragmentos HTML, paginación, orden flexible y plantillas personalizables por callback.

## Cuándo usarlo
- Listados de cualquier `postType` con layout consistente y reutilizable.
- Separar consulta (datos) del marcado (plantilla por item).
- Caché automática con invalidación al modificar contenido.

## API básica

```php
use Glory\Components\ContentRender;

ContentRender::print(
    string $postType,    // Tipo de post: 'post', 'page', 'portfolio', etc.
    array $opciones = [] // Configuración completa abajo
): void;
```

### Opciones principales (las más usadas)

```php
ContentRender::print('post', [
    // CONTENIDO Y CONSULTA
    'publicacionesPorPagina' => 10,   // int: elementos por página
    'argumentosConsulta' => [],        // array: args adicionales para WP_Query (meta_query, tax_query, post__in, etc.)
    'orden' => 'fecha',                // string: 'fecha' | 'random' | 'meta'
    'metaKey' => null,                 // string|null: clave meta (requerido si orden='meta')
    'idsPreferidos' => [],             // array: IDs que aparecen primero, el resto mantiene su orden
    
    // PLANTILLA
    'plantilla' => 'miPlantillaId',    // string: ID registrado en TemplateRegistry o archivo en App/Templates/
    // O usar callback directo:
    'plantillaCallback' => function(\WP_Post $post, string $itemClass): void {
        // Tu HTML aquí
    },
    
    // CLASES CSS
    'claseContenedor' => 'glory-content-list', // string: clase del contenedor principal
    'claseItem' => 'glory-content-item',       // string: clase de cada item
    
    // PAGINACIÓN
    'paginacion' => false,             // bool: activar estructura para paginación
    
    // CACHÉ
    'tiempoCache' => HOUR_IN_SECONDS,  // int: segundos de caché (3600 por defecto)
    'forzarSinCache' => false,         // bool: ignorar caché para esta llamada
]);
```

### Opciones de layout

```php
ContentRender::print('post', [
    // MODO DE DISPLAY
    'display_mode' => 'flex',          // string: 'block' | 'flex' | 'grid'
    'gap' => '20px',                   // string: espaciado entre items
    
    // OPCIONES FLEX (cuando display_mode='flex')
    'flex_direction' => 'row',         // string: 'row' | 'column'
    'flex_wrap' => 'wrap',             // string: 'nowrap' | 'wrap'
    'justify_content' => 'flex-start', // string: 'flex-start' | 'center' | 'flex-end' | 'space-between' | 'space-around'
    'align_items' => 'stretch',        // string: 'stretch' | 'flex-start' | 'center' | 'flex-end'
    
    // OPCIONES GRID (cuando display_mode='grid')
    'grid_columns' => 3,               // int: número de columnas
    'grid_min_width' => '250px',       // string: ancho mínimo por item
]);
```

### Opciones de imagen

```php
ContentRender::print('post', [
    'img_show' => true,                // bool: mostrar imagen destacada
    'img_size' => 'medium',            // string: tamaño WP ('thumbnail', 'medium', 'large', 'full')
    'img_aspect_ratio' => null,        // string|null: aspect ratio CSS (ej: '16/9', '4/3', '1/1')
    'img_object_fit' => 'cover',       // string: 'cover' | 'contain'
    'imgOptimize' => true,             // bool: usar ImageUtility para optimización
    'imgQuality' => 60,                // int: calidad de compresión (1-100)
]);
```

### Opciones de título

```php
ContentRender::print('post', [
    'title_show' => true,              // bool: mostrar título
    'title_position' => 'top',         // string: 'top' | 'bottom'
    'title_show_on_hover' => false,    // bool: título visible solo en hover
    'title_font_size' => null,         // string|null: tamaño fuente (ej: '18px', '1.2rem')
    'title_color' => null,             // string|null: color del título
]);
```

### Opciones UI agnósticas (para JavaScript externo)

```php
ContentRender::print('post', [
    'acciones' => [],                  // array: acciones disponibles (ej: ['eliminar', 'editar'])
    'submenu' => false,                // bool: habilitar submenús (data-submenu-enabled)
    'eventoAccion' => 'dblclick',      // string: 'click' | 'dblclick' | 'longpress'
    'selectorItem' => '[id^="post-"]', // string: selector CSS para identificar items
]);
```

### Filtro por categorías

```php
ContentRender::print('post', [
    'categoryFilter' => [
        'enabled' => false,            // bool: activar filtro por categorías
        'allLabel' => 'All',           // string: etiqueta del botón "Todos"
    ],
]);
```

### Modo de interacción

```php
ContentRender::print('post', [
    'interaccion_modo' => 'normal',    // string: 'normal' | 'carousel' | 'toggle'
]);
```

## Parámetros complejos

### argumentosConsulta
Se fusiona con los args base de `WP_Query`. Permite pasar cualquier parámetro válido de WP_Query:

```php
ContentRender::print('post', [
    'argumentosConsulta' => [
        // Filtrar por taxonomía
        'tax_query' => [
            [
                'taxonomy' => 'category',
                'field' => 'slug',
                'terms' => ['noticias', 'eventos'],
            ],
        ],
        
        // Filtrar por meta
        'meta_query' => [
            [
                'key' => 'destacado',
                'value' => '1',
                'compare' => '=',
            ],
        ],
        
        // Posts específicos (respeta el orden si no hay orderby)
        'post__in' => [15, 23, 8, 42],
        
        // Excluir posts
        'post__not_in' => [1, 2, 3],
        
        // Semilla para orden random estable
        'glory_rand_seed' => 12345,
    ],
]);
```

### orden='random' con semilla estable
El orden aleatorio usa `RAND(seed)` para mantener consistencia entre páginas:

```php
ContentRender::print('post', [
    'orden' => 'random',
    'argumentosConsulta' => [
        'glory_rand_seed' => 12345,  // Semilla fija = mismo orden siempre
    ],
]);
// Sin semilla explícita, se genera una basada en HTTP_REFERER o REQUEST_URI
```

### idsPreferidos
Reordena los resultados colocando IDs específicos al inicio sin excluir otros posts:

```php
ContentRender::print('post', [
    'idsPreferidos' => [15, 23, 8],  // Estos aparecen primero, luego el resto
    'publicacionesPorPagina' => 10,
]);
// Resultado: [15, 23, 8, ...otros posts según orden configurado...]
```

## Ejemplo mínimo

```php
use Glory\Components\ContentRender;

// Listado básico con plantilla registrada
ContentRender::print('post', [
    'publicacionesPorPagina' => 6,
    'plantilla' => 'miPlantilla',
]);
```

## Ejemplo con layout grid y filtros

```php
ContentRender::print('portfolio', [
    'publicacionesPorPagina' => 12,
    'plantilla' => 'cardPortfolio',
    
    // Layout
    'display_mode' => 'grid',
    'grid_columns' => 3,
    'gap' => '24px',
    
    // Imágenes
    'img_show' => true,
    'img_aspect_ratio' => '16/9',
    'imgOptimize' => true,
    
    // Título
    'title_position' => 'bottom',
    
    // Filtro por categorías
    'categoryFilter' => [
        'enabled' => true,
        'allLabel' => 'Todos',
    ],
]);
```

## Ejemplo con orden aleatorio y priorización

```php
ContentRender::print('producto', [
    'publicacionesPorPagina' => 8,
    'orden' => 'random',
    'argumentosConsulta' => ['glory_rand_seed' => 12345],
    'idsPreferidos' => [15, 23, 8],  // Estos primero, luego aleatorio
    'paginacion' => true,
]);
```

## Ejemplo con consulta avanzada

```php
// Eventos futuros ordenados por fecha del evento
ContentRender::print('evento', [
    'publicacionesPorPagina' => 10,
    'orden' => 'meta',
    'metaKey' => 'fecha_evento',
    'argumentosConsulta' => [
        'order' => 'ASC',
        'meta_query' => [
            [
                'key' => 'fecha_evento',
                'value' => date('Y-m-d'),
                'compare' => '>=',
                'type' => 'DATE',
            ],
        ],
    ],
]);
```

## Acceso a datos en plantillas

Dentro de una plantilla callback puedes acceder al contexto del render actual:

```php
use Glory\Components\ContentRender;

function miPlantilla(\WP_Post $post, string $itemClass): void {
    // Índice del item actual (1-based)
    $indice = ContentRender::getCurrentOption('indiceItem', 0);
    $esPar = $indice % 2 0;
    
    // Categorías del post actual (si categoryFilter está activo)
    $categorias = ContentRender::getCurrentOption('currentCategories', []);
    // $categorias es array de ['slug' => 'mi-cat', 'label' => 'Mi Categoría']
    
    // Cualquier opción de configuración del render
    $mostrarImg = ContentRender::getCurrentOption('img_show', true);
    $modoDisplay = ContentRender::getCurrentOption('display_mode', 'flex');
    $imgSize = ContentRender::getCurrentOption('img_size', 'medium');
    
    ?>
    <article class="<?php echo esc_attr($itemClass . ($esPar ? ' par' : ' impar')); ?>">
        <!-- Tu HTML -->
    </article>
    <?php
}
```

### Compartir datos personalizados

```php
// Antes de llamar a print(), establecer datos
ContentRender::setCurrentOption('miConfigCustom', ['clave' => 'valor']);

ContentRender::print('post', ['plantilla' => 'miPlantilla']);

// Dentro de la plantilla, acceder
$config = ContentRender::getCurrentOption('miConfigCustom', []);
```

## Clases CSS generadas

ContentRender genera clases únicas por instancia para CSS aislado:

```html
<!-- Contenedor principal -->
<div class="glory-content-list portfolio glory-cr-a1b2c3d4"
     data-post-type="portfolio"
     data-publicaciones-por-pagina="12"
     ...>
    
    <!-- Cada item -->
    <div class="glory-content-item portfolio-item glory-cr-a1b2c3d4__item post-id-123 posicion-1 impar">
        <!-- Contenido de la plantilla -->
    </div>
</div>
```

La clase de instancia (`glory-cr-XXXX`) permite que el CSS generado por `ContentRenderCss` no colisione entre múltiples llamadas a ContentRender en la misma página.

## Estructura HTML con paginación

Cuando `paginacion => true`:

```html
<div class="glory-pagination-container"
     data-nonce="..."
     data-post-type="post"
     data-posts-per-page="10"
     data-template-callback="..."
     data-content-target=".glory-content-target"
     data-pagination-target=".glory-pagination-target">
    
    <div class="glory-content-target">
        <!-- Contenido renderizado -->
    </div>
    
    <div class="glory-pagination-target">
        <!-- Controles de paginación (via PaginationRenderer) -->
    </div>
</div>
```

## Recomendaciones

- **Usa `plantilla` en lugar de `plantillaCallback`** para reutilizar plantillas entre distintas llamadas.
- **Registra plantillas** via `TemplateRegistry::register()` o coloca archivos en `App/Templates/` (TemplateManager las detecta automáticamente).
- **Usa las clases CSS estándar** en tus plantillas (`glory-cr__title`, `glory-cr__image`, `glory-cr__stack`, `glory-cr__content`) para que el CSS por instancia funcione correctamente.
- **Inicializa los hooks de caché** llamando `ContentRender::initHooks()` una vez en el setup del tema.
- Consulta `introduccion/como-crear-plantillas-content-render` para guía completa de plantillas.

## Notas y edge cases

- **post__in sin orderby**: Se respeta el orden explícito del array.
- **Deduplicación automática**: Se aplica `DISTINCT` para evitar duplicados en consultas complejas.
- **orden='meta'**: Requiere `metaKey` definido, de lo contrario usa orden por fecha.
- **Clase de instancia**: Cada llamada genera `glory-cr-XXXX` único para CSS aislado.
- **minPaginas**: Opción interna para forzar número mínimo de páginas en paginación.

## Integración con el tema

```php
// En una plantilla del tema (ej: page-portfolio.php)
use Glory\Components\ContentRender;

get_header();

ContentRender::print('portfolio', [
    'publicacionesPorPagina' => 9,
    'plantilla' => 'cardPortfolio',
    'display_mode' => 'grid',
    'grid_columns' => 3,
]);

get_footer();
```

## Modo Dev/Local

- **WP_DEBUG=true**: No se usa caché, el contenido se renderiza directamente en cada petición.
- **WP_DEBUG=false (producción)**: Se usa caché con el tiempo especificado en `tiempoCache`.
- **Invalidación automática**: `initHooks()` registra limpieza de caché al crear/editar/eliminar/restaurar posts.
- **Claves de caché**: Segmentadas por configuración y número de página (`paged`).

```php
// En functions.php o setup del tema
add_action('after_setup_theme', function() {
    \Glory\Components\ContentRender::initHooks();
});
```

## Errores frecuentes

1. **Caché no se actualiza**
```php
// Para depurar, forzar sin caché
ContentRender::print('post', ['forzarSinCache' => true]);

// O limpiar caché manualmente
ContentRender::clearCacheForPostType('post');
ContentRender::clearAllContentCaches();
```

2. **Paginación no funciona**
   - Verifica que `paginacion => true` esté configurado.
   - Si usas AJAX, tu JavaScript debe capturar los enlaces de paginación.

3. **Orden por meta no funciona**
   - Asegura que `metaKey` esté definido cuando `orden => 'meta'`.
   - Verifica que los posts tengan ese meta_key.

4. **Plantilla no se encuentra**
   - Verifica que esté registrada en `TemplateRegistry` o que el archivo exista en `App/Templates/`.
   - El nombre del archivo debe coincidir con el ID de la plantilla.

## API avanzada

```php
use Glory\Components\ContentRender;

// HOOKS DE CACHÉ
// Registrar limpieza automática (llamar una vez en setup)
ContentRender::initHooks(): void;

// GESTIÓN DE CACHÉ
// Limpiar caché de un post type específico
ContentRender::clearCacheForPostType(string $postType): void;

// Limpiar toda la caché de ContentRender
ContentRender::clearAllContentCaches(): void;

// Callback interno para limpieza (se registra con initHooks)
ContentRender::clearCacheOnPostChange(int $postId): void;

// PLANTILLAS INCLUIDAS
// Plantilla por defecto (título, imagen, excerpt)
ContentRender::defaultTemplate(\WP_Post $post, string $itemClass): void;

// Plantilla de contenido completo (sin título ni imagen, solo content)
ContentRender::fullContentTemplate(\WP_Post $post, string $itemClass): void;

// COMPARTIR DATOS CON PLANTILLAS
// Obtener opción del contexto actual
ContentRender::getCurrentOption(string $key, $default = null): mixed;

// Establecer opción en el contexto actual
ContentRender::setCurrentOption(string $key, $value): void;

// CONFIGURACIÓN GBN (Glory Builder Native)
// Retorna configuración y schema para el builder visual
ContentRender::gbnDefaults(): array;
// Retorna: ['config' => [...defaults...], 'schema' => [...campos UI...]]
```

## Dependencias

- `WP_Query` — Consultas WordPress
- `Glory\Components\PaginationRenderer` — Controles de paginación
- `Glory\Utility\ImageUtility` — Optimización de imágenes (opcional)
- `Glory\Support\CSS\ContentRenderCss` — Generación de CSS por instancia
- `Glory\Utility\TemplateRegistry` — Registro de plantillas por código
- `Glory\Manager\TemplateManager` — Detección de plantillas en `App/Templates/`
