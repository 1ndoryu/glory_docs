---
title: GloryFeatures
description: Control de features y overrides en Glory
---

`GloryFeatures` centraliza el control de funcionalidades (features) que pueden activarse/desactivarse
mediante código o mediante opciones en el panel. Esta página documenta la API pública, la precedencia
entre overrides por código y opciones de la base de datos, y patrones de uso recomendados.

## Concepto

- Una *feature* es una funcionalidad opcional del framework (p. ej. `gloryRealtime`, `cssCritico`).
- Glory permite controlar el estado de una feature desde dos fuentes principales:
  1. **Override por código**: el desarrollador puede forzar la activación/desactivación en tiempo de ejecución.
  2. **Opción en la base de datos**: una opción gestionada por `OpcionManager` que el administrador puede cambiar desde el panel.

## API principal

- `GloryFeatures::enable(string $feature): void` — Activa permanentemente la feature en el runtime.
- `GloryFeatures::disable(string $feature): void` — Desactiva permanentemente la feature en el runtime.
- `GloryFeatures::isEnabled(string $feature): ?bool` — Devuelve el override por código: `true`, `false` o `null` si no hay override.
- `GloryFeatures::isActive(string $feature, ?string $optionKey = null, bool $default = true): bool` — Decide si la feature está activa combinando override y opción en BD.

> Nota: `isActive` es la llamada que normalmente debes usar cuando registras assets, hooks o funcionalidades dependientes de la configuración.

## Precedencia y comportamiento (explicación muy sencilla)

- `isEnabled('feature')` — pregunta si el desarrollador **forzó** la feature en el código.
  - Devuelve `true` = forzó activarla.
  - Devuelve `false` = forzó desactivarla.
  - Devuelve `null` = no hay override por código.

- `isActive('feature', $optionKey, $default)` — devuelve si la feature está realmente activa en el sitio. Reglas simples:
  1. Si `isEnabled` devuelve `true` o `false`, `isActive` devuelve ese valor (el override por código manda).
  2. Si `isEnabled` devuelve `null`, `isActive` mira la opción en la base de datos (`optionKey`):
     - Si la opción existe en BD, devuelve ese valor (lo que configuró el administrador).
     - Si la opción no existe, devuelve `default` (valor por defecto que tú pases).

Ejemplos rápidos:

- Caso 1: el dev hizo `isEnabled('X') === true` → `isActive('X')` devuelve `true`.
- Caso 2: `isEnabled('X') === null`, en BD `optionKey` = `false` → `isActive` devuelve `false`.
- Caso 3: `isEnabled('X') === null`, en BD no existe la opción → `isActive` devuelve `default`.

Pseudocódigo sencillo:

```php
$override = GloryFeatures::isEnabled('X'); // true | false | null
if ($override !== null) return $override;
if (option_exists('optionKey')) return get_option('optionKey');
return $default;
```

## Ejemplos extras

1) Dev ON — el dev forzó activar

```php
// dev mode = true
GloryFeatures::enable('X'); // override = true
GloryFeatures::isActive('X') // -> true
```

2) Dev ON — el dev forzó desactivar

```php
// dev mode = true
GloryFeatures::disable('X'); // override = false
GloryFeatures::isActive('X') // -> false
```

3) Dev ON — no hay override, la BD tiene la opción

```php
// dev mode = true
// override = null
// DB: optionKey = true
GloryFeatures::isActive('X', 'mi_opcion') // -> true
```

4) Prod (dev OFF) — el dev forzó activar pero el admin dijo false en BD

```php
// dev mode = false
GloryFeatures::enable('X'); // override = true
// DB: optionKey = false
GloryFeatures::isActive('X', 'mi_opcion') // -> false
```

5) Prod (dev OFF) — el dev forzó activar y NO existe opción en BD

```php
// dev mode = false
GloryFeatures::enable('X'); // override = true
// DB: optionKey NO existe
GloryFeatures::isActive('X', 'mi_opcion', true) // -> true
```

6) Prod (dev OFF) — no override y la BD tiene false

```php
// dev mode = false
// override = null
// DB: optionKey = false
GloryFeatures::isActive('X', 'mi_opcion') // -> false
```

## ¿Por qué existen las dos funciones? ¿Tiene que ver con el modo dev?

- `isEnabled` sirve para que un desarrollador pueda **forzar** algo desde el código (útil en desarrollo o pruebas). Es temporal y local al código.
- `isActive` es la **decisión final** que usa el sistema: combina override, configuración del admin y un valor por defecto.
- En **modo desarrollo** los overrides por código suelen tener prioridad absoluta (para facilitar pruebas).
- En **producción** el override actúa como **valor por defecto**: si el admin ya configuró la opción en BD, la opción del admin gana.

Ejemplo práctico para entenderlo:

- Estás desarrollando y quieres probar una feature sin tocar el panel: `GloryFeatures::enable('miFeature')` → `isActive('miFeature')` devolverá `true` en tu entorno local.
- En producción, si el admin ya decidió que la feature esté `false` en el panel, `isActive` devolverá `false` aunque el código llame a `enable()` (el admin tiene la última palabra en producción).

---

### Integración con `AssetManager`

`AssetManager` soporta la clave `feature` en la configuración de un asset. Si un asset declara `'feature' => 'miFeature'`,
el manager comprobará internamente `GloryFeatures::isActive('miFeature')` y **omitirá** la definición/encolado del asset cuando la
feature esté desactivada. Esto permite simplificar la declaración de assets en `App/Config/assets.php` sin envolver el código
con condicionales.

Formato aceptado:

- `feature` (string): nombre de la feature, p. ej. `'gloryAjax'`.
- `feature` (array): `['name' => 'gloryAjax', 'option' => 'clave_opcion_en_bd']` para mapear una opción distinta.

Ejemplo rápido:

```php
AssetManager::define(
    'script',
    'glory-realtime-core',
    '/Glory/assets/js/Core/gloryRealtime.js',
    [
        'deps'    => [],
        'in_footer'=> true,
        'area'    => 'both',
        'feature' => 'gloryAjax', // el asset solo se definirá/encolará si la feature gloryAjax está activa
    ]
);
```

Con esta integración, no necesitas envolver la llamada a `AssetManager::define()` en un `if (GloryFeatures::isActive(...))` —
AssetManager se encarga de respetar la configuración de features automáticamente.

## Ejemplos de uso

### Forzar una feature desde código (override)

```php
use Glory\Core\GloryFeatures;

// Forzar activación
GloryFeatures::enable('gloryRealtime');

// Forzar desactivación
GloryFeatures::disable('cssCritico');
```

### Comprobar si una feature está activa (modo recomendado al registrar assets)

```php
use Glory\Manager\AssetManager;
use Glory\Core\GloryFeatures;

if (GloryFeatures::isActive('gloryRealtime')) {
    AssetManager::define('script', 'glory-gloryrealtime', '/assets/js/gloryRealtime.js', [
        'deps' => ['glory-ajax'],
        'in_footer' => true,
        'area' => 'frontend',
    ]);
}
```

### `isActive` con `optionKey`

Si la opción en BD usa una clave personalizada diferente al nombre de la feature, pásala como segundo parámetro:

```php
// Si la opción real en BD es 'mi_plugin_realtime_enabled'
GloryFeatures::isActive('gloryRealtime', 'mi_plugin_realtime_enabled');
```

## Buenas prácticas

- Usa `isActive()` siempre que el comportamiento deba depender de la configuración del sitio o de un override por código.
- Reserva `isEnabled()` para casos en los que exclusivamente quieras comprobar si existe un override por código.
- Evita usar valores por defecto inconsistentes: cuando definas una feature documenta el `optionKey` y el `default` esperado.
- Para assets que solo deberían cargarse en admin o frontend, define `area` en el `AssetManager` y consulta `isActive()` antes de definir el asset.
- Documenta en la documentación del componente o del tema (p. ej. el README correspondiente) cada feature nueva con su `optionKey`, `valorDefault`, y ejemplos de uso (enable/disable/isActive).

## Errores comunes

- No comprobar `isActive()` antes de registrar assets o hooks: puede provocar que assets innecesarios se registren en entornos donde la feature debe estar desactivada.
- Confundir `isEnabled()` con `isActive()` y depender únicamente de `isEnabled()` en código que debe respetar la configuración del panel.



