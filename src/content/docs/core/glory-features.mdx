---
title: GloryFeatures
description: Control programático de funcionalidades y gestión de overrides en Glory Framework.
sidebar:
  order: 1
---

`GloryFeatures` es la clase central para gestionar la activación y desactivación de funcionalidades (features) en el framework. Permite definir estados por defecto desde el código y respeta la configuración del usuario almacenada en base de datos, con comportamientos específicos para entornos de desarrollo y producción.

## Cuándo usarlo

- Para activar o desactivar módulos del framework condicionalmente.
- Para definir el estado por defecto de una funcionalidad que luego podrá ser gestionada desde el panel de administración.
- Para comprobar si una funcionalidad está activa antes de registrar assets, hooks o servicios.

## API Básica

```php
use Glory\Core\GloryFeatures;

// Activar una funcionalidad (override por código)
GloryFeatures::enable('nombreFeature');

// Desactivar una funcionalidad (override por código)
GloryFeatures::disable('nombreFeature');

// Comprobar si una funcionalidad está activa (resolución final)
if (GloryFeatures::isActive('nombreFeature')) {
    // Lógica de la feature...
}
```

### Parámetros Complejos: `isActive`

El método `isActive` es el más importante y realiza una resolución en cascada para determinar el estado final.

`public static function isActive(string $feature, ?string $optionKey = null, bool $defaultOption = true): bool`

- **$feature**: Nombre de la funcionalidad (se normaliza automáticamente a camelCase).
- **$optionKey**: (Opcional) Clave específica de la opción en base de datos. Si es `null`, el sistema buscará automáticamente claves siguiendo convenciones (ver abajo).
- **$defaultOption**: Valor de retorno si no hay override por código ni opción en base de datos.

## Resolución de Estado (Dev vs Prod)

El comportamiento de `isActive` cambia según el entorno para facilitar el desarrollo sin afectar la producción accidentalmente.

### Modo Desarrollo (`WP_DEBUG` o `AssetManager::isGlobalDevMode()`)
El **código manda**.
1. Si se llamó a `enable('feature')`, devuelve `true`.
2. Si se llamó a `disable('feature')`, devuelve `false`.
3. Si no hay override por código, busca la opción en BD o usa el default.

### Modo Producción
El **panel de administración (BD) manda**.
1. Si existe una opción guardada en la base de datos para esta feature, se usa ese valor.
2. Si **NO** existe opción en BD, se usa el estado definido por código (`enable`/`disable`) como valor por defecto.
3. Si no hay ni opción en BD ni override por código, se usa el argumento `$defaultOption`.

> **Importante:** En producción, `GloryFeatures::enable('foo')` no fuerza la activación si el usuario la ha desactivado explícitamente en el panel. Simplemente establece que "por defecto debería estar activa".

## Resolución de Claves de Opción

Si no se especifica `$optionKey`, `isActive` buscará opciones en `OpcionManager` siguiendo este orden de prioridad (usando el nombre de la feature convertido a `snake_case`):

1. `glory_componente_{feature}_activado` (Convención principal)
2. `glory_{feature}_activado` (Convención legacy)
3. `glory_{sufijo}_service_activado` (Si la feature empieza por `glory_`)

## Ejemplo Mínimo

```php
use Glory\Core\GloryFeatures;

// 1. Definir estado por defecto (opcional, idealmente en un ServiceProvider o functions.php)
GloryFeatures::enable('sistemaComentarios');

// 2. Usar la feature
if (GloryFeatures::isActive('sistemaComentarios')) {
    // Esta lógica se ejecutará salvo que se desactive explícitamente en el panel (en Prod)
    add_action('init', 'iniciar_comentarios');
}
```

## API Avanzada

Métodos para inspección directa del estado en código, sin consultar base de datos.

```php
// Comprueba si se ha definido un override por código (true/false) o no (null)
$estadoCodigo = GloryFeatures::isEnabled('miFeature'); 

// Comprueba si se ha seteado algún valor (true o false)
$estaSeteado = GloryFeatures::isSet('miFeature');
```

### Normalización y Alias
El sistema normaliza las claves a `camelCase`.
- `schedule-manager` -> `scheduleManager`
- `mi_feature` -> `miFeature`

Existen alias históricos para compatibilidad:
- `schedulemanager`, `schedule_manager` -> `scheduler`
- `gestionarpreviews` -> `previews`

## Recomendaciones

- **Nombres de Features**: Usa `camelCase` para consistencia (`miFeatureNueva`).
- **Ubicación**: Las llamadas a `enable`/`disable` deben hacerse temprano en la carga (ej. `after_setup_theme` o en el constructor de un servicio) para asegurar que estén disponibles cuando otros componentes verifiquen `isActive`.
- **Opciones**: Si creas una nueva feature que requiere opción en panel, asegúrate de registrar la opción en `OpcionManager` con la clave `glory_componente_{feature_snake}_activado` para que la resolución automática funcione.

## Errores Frecuentes

- **Asumir que `enable()` siempre activa en Producción**: Recordar que en producción la base de datos tiene prioridad.
- **Usar claves inconsistentes**: Aunque el sistema normaliza, es mejor usar siempre el mismo formato (camelCase) para evitar confusiones.
- **Confusión con Alias**: Si usas `schedule-manager`, internamente se guarda como `scheduler`. Si buscas la opción manual `glory_componente_schedule_manager_activado` fallará; buscará `glory_componente_scheduler_activado`.
