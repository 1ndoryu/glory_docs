---
title: GloryFeatures
description: Control de features y overrides en Glory
---

`GloryFeatures` centraliza el control de funcionalidades (features) que pueden activarse/desactivarse
mediante código o mediante opciones en el panel. Esta página documenta la API pública, la precedencia
entre overrides por código y opciones de la base de datos, y patrones de uso recomendados.

## Concepto

- Una *feature* es una funcionalidad opcional del framework (p. ej. `gloryRealtime`, `cssCritico`).
- Glory permite controlar el estado de una feature desde dos fuentes principales:
  1. **Override por código**: el desarrollador puede forzar la activación/desactivación en tiempo de ejecución.
  2. **Opción en la base de datos**: una opción gestionada por `OpcionManager` que el administrador puede cambiar desde el panel.

## API principal

- `GloryFeatures::enable(string $feature): void` — Activa permanentemente la feature en el runtime.
- `GloryFeatures::disable(string $feature): void` — Desactiva permanentemente la feature en el runtime.
- `GloryFeatures::isEnabled(string $feature): ?bool` — Devuelve el override por código: `true`, `false` o `null` si no hay override.
- `GloryFeatures::isActive(string $feature, ?string $optionKey = null, bool $default = true): bool` — Decide si la feature está activa combinando override y opción en BD.

> Nota: `isActive` es la llamada que normalmente debes usar cuando registras assets, hooks o funcionalidades dependientes de la configuración.

## Precedencia y comportamiento

1. `isEnabled` comprueba si hay un override aplicado por código y devuelve `true`, `false` o `null`.
2. `isActive` hace lo siguiente internamente:
   - Si `isEnabled` devuelve `true` o `false`, `isActive` respeta ese valor (override por código tiene prioridad).
   - Si no hay override (`null`), `isActive` consulta la opción en la base de datos indicada por `optionKey`. Si la opción no existe, aplica `default`.

Esto permite que el desarrollador pueda forzar rápidamente comportamientos sin alterar la configuración almacenada, y al mismo
tiempo que los administradores mantengan control desde el panel.

## Modo desarrollo vs producción — detalle técnico

Glory decide si está en "modo desarrollo" comprobando dos señales:

- `AssetManager::isGlobalDevMode()` si el AssetManager expone un flag global (puede establecerse con `AssetManager::setGlobalDevMode(true)`).
- La constante `WP_DEBUG` (si está definida y es `true`).

En el código esto se evalúa así (simplificado):

- `isDevMode = AssetManager::isGlobalDevMode() || (defined('WP_DEBUG') && WP_DEBUG)`

Comportamiento dependiendo del modo:

- En **modo desarrollo** (dev): el override por código tiene **máxima prioridad**. Si llamas a `GloryFeatures::enable('X')` o `disable('X')`,
  `isActive('X')` devolverá ese valor inmediatamente y no consultará la opción en la base de datos. Esto facilita pruebas y cambios rápidos durante
  el desarrollo.
- En **producción** (dev mode apagado): el override por código **no fuerza** el resultado final del sistema; en su lugar actúa como **valor por defecto**.
  Si existe una opción registrada en el `OpcionRegistry` para esa feature, `isActive` devolverá el valor almacenado por el administrador en la BD
  (consultando `OpcionManager::get($key, $default)`), usando el override como `default` cuando está presente. Esto protege la configuración
  del sitio en producción frente a cambios accidentales realizados por código.

Flujo interno resumido de `isActive` en producción:

1. Normaliza el nombre de la feature y calcula `overridden = isEnabled(...)`.
2. Si `overridden` no es `null`, lo usa como `defaultOption`.
3. Genera una lista de `candidateKeys` (claves de opción posibles) siguiendo convenciones como `glory_componente_xxx_activado` y variantes históricas.
4. Busca la primera clave presente en `OpcionRegistry` y, si existe, devuelve `OpcionManager::get(key, defaultOption)`.
5. Si ninguna clave está registrada, devuelve `defaultOption`.

Implicación práctica ("protección"):

- En producción, la existencia de una opción registrada en el `OpcionRegistry` garantiza que el administrador pueda controlar la feature desde el panel
  y que un override por código no la anule silenciosamente. Para impedir que un developer cambie permanentemente una feature en producción,
  registra la opción correspondiente en el `OpcionRegistry`/`OpcionManager`; `isActive` respetará el valor en BD.

Cómo forzar comportamiento de desarrollo en un entorno local o temporalmente:

- Puedes activar `WP_DEBUG` o llamar a `AssetManager::setGlobalDevMode(true)` en tu bootstrap local para que los overrides por código tengan prioridad.


### Integración con `AssetManager`

`AssetManager` soporta la clave `feature` en la configuración de un asset. Si un asset declara `'feature' => 'miFeature'`,
el manager comprobará internamente `GloryFeatures::isActive('miFeature')` y **omitirá** la definición/encolado del asset cuando la
feature esté desactivada. Esto permite simplificar la declaración de assets en `App/Config/assets.php` sin envolver el código
con condicionales.

Formato aceptado:

- `feature` (string): nombre de la feature, p. ej. `'gloryAjax'`.
- `feature` (array): `['name' => 'gloryAjax', 'option' => 'clave_opcion_en_bd']` para mapear una opción distinta.

Ejemplo rápido:

```php
AssetManager::define(
    'script',
    'glory-realtime-core',
    '/Glory/assets/js/Core/gloryRealtime.js',
    [
        'deps'    => [],
        'in_footer'=> true,
        'area'    => 'both',
        'feature' => 'gloryAjax', // el asset solo se definirá/encolará si la feature gloryAjax está activa
    ]
);
```

Con esta integración, no necesitas envolver la llamada a `AssetManager::define()` en un `if (GloryFeatures::isActive(...))` —
AssetManager se encarga de respetar la configuración de features automáticamente.

## Ejemplos de uso

### Forzar una feature desde código (override)

```php
use Glory\Core\GloryFeatures;

// Forzar activación
GloryFeatures::enable('gloryRealtime');

// Forzar desactivación
GloryFeatures::disable('cssCritico');
```

### Comprobar si una feature está activa (modo recomendado al registrar assets)

```php
use Glory\Manager\AssetManager;
use Glory\Core\GloryFeatures;

if (GloryFeatures::isActive('gloryRealtime')) {
    AssetManager::define('script', 'glory-gloryrealtime', '/assets/js/gloryRealtime.js', [
        'deps' => ['glory-ajax'],
        'in_footer' => true,
        'area' => 'frontend',
    ]);
}
```

### `isActive` con `optionKey`

Si la opción en BD usa una clave personalizada diferente al nombre de la feature, pásala como segundo parámetro:

```php
// Si la opción real en BD es 'mi_plugin_realtime_enabled'
GloryFeatures::isActive('gloryRealtime', 'mi_plugin_realtime_enabled');
```

## Buenas prácticas

- Usa `isActive()` siempre que el comportamiento deba depender de la configuración del sitio o de un override por código.
- Reserva `isEnabled()` para casos en los que exclusivamente quieras comprobar si existe un override por código.
- Evita usar valores por defecto inconsistentes: cuando definas una feature documenta el `optionKey` y el `default` esperado.
- Para assets que solo deberían cargarse en admin o frontend, define `area` en el `AssetManager` y consulta `isActive()` antes de definir el asset.
- Documenta en la documentación del componente o del tema (p. ej. el README correspondiente) cada feature nueva con su `optionKey`, `valorDefault`, y ejemplos de uso (enable/disable/isActive).

## Errores comunes

- No comprobar `isActive()` antes de registrar assets o hooks: puede provocar que assets innecesarios se registren en entornos donde la feature debe estar desactivada.
- Confundir `isEnabled()` con `isActive()` y depender únicamente de `isEnabled()` en código que debe respetar la configuración del panel.



