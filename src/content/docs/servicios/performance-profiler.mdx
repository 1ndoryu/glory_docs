---
title: PerformanceProfiler
description: Servicio de profiling de rendimiento para medir tiempo de ejecuci√≥n de funciones y componentes
sidebar:
  label: PerformanceProfiler
  order: 4
---

import { Steps, Tabs, TabItem, Aside } from '@astrojs/starlight/components';

# PerformanceProfiler

El **PerformanceProfiler** es un servicio avanzado de medici√≥n de rendimiento dise√±ado para Glory Framework. Permite medir el tiempo de ejecuci√≥n de funciones, componentes y servicios espec√≠ficos, identificando cuellos de botella y optimizando el rendimiento de la aplicaci√≥n.

## Filosof√≠a

PerformanceProfiler est√° dise√±ado para ser:
- **No intrusivo**: Solo se activa en desarrollo o cuando est√° expl√≠citamente habilitado
- **Flexible**: Soporta medici√≥n de funciones individuales o bloques completos
- **Detallado**: Captura tiempo de ejecuci√≥n, uso de memoria y llamadas m√∫ltiples
- **Integrado**: Se integra con GloryLogger para logging autom√°tico

## Caracter√≠sticas Principales

- **Medici√≥n precisa**: Usa `microtime(true)` para mediciones de alta precisi√≥n
- **Seguimiento de memoria**: Registra uso de memoria m√°ximo por componente
- **Contador de llamadas**: Detecta funciones/componentes que se ejecutan m√∫ltiples veces
- **Logging autom√°tico**: Registra todas las mediciones en `debug.log`
- **Resumen final**: Muestra estad√≠sticas globales al finalizar la petici√≥n
- **Exclusi√≥n inteligente**: Se desactiva autom√°ticamente en AJAX, REST API y cron

## Inicializaci√≥n

### Configuraci√≥n B√°sica

```php
use Glory\Services\PerformanceProfiler;

// Inicializar el profiler (se activa autom√°ticamente seg√∫n configuraci√≥n)
PerformanceProfiler::init();
```

### Control de Activaci√≥n

El profiler se controla mediante:

1. **Feature flag**: `GloryFeatures::isActive('performanceProfiler', 'glory_performance_profiler_activo', false)`
2. **Opci√≥n de BD**: `glory_performance_profiler_activo` (checkbox en panel de opciones)
3. **Modo desarrollo**: Se activa autom√°ticamente en `WP_DEBUG = true`

### Configuraci√≥n en Panel de Opciones

```php
// En functions.php o archivo de configuraci√≥n
OpcionManager::register('glory_performance_profiler_activo', [
    'type' => 'checkbox',
    'label' => 'Activar PerformanceProfiler',
    'description' => 'Mide rendimiento de funciones y componentes en modo desarrollo',
    'default' => false,
    'section' => 'glory_debug'
]);
```

## Uso B√°sico

### Medici√≥n Manual

```php
use Glory\Services\PerformanceProfiler;

// Iniciar medici√≥n
PerformanceProfiler::start('mi-funcion-personalizada');

// C√≥digo a medir
miFuncionQueHaceAlgo();

// Terminar medici√≥n
PerformanceProfiler::end('mi-funcion-personalizada');
```

### Medici√≥n con Helper

```php
// Medir una funci√≥n completa autom√°ticamente
$resultado = PerformanceProfiler::medirFuncion(function() {
    // C√≥digo a ejecutar y medir
    return miFuncionCompleja($param1, $param2);
}, 'funcion-compleja', 'service');
```

### Medici√≥n en Componentes Glory

```php
class MiServicio
{
    public function procesarDatos($datos)
    {
        PerformanceProfiler::start('MiServicio::procesarDatos', 'service');

        try {
            // L√≥gica del m√©todo
            $resultado = $this->validarDatos($datos);
            $resultado = $this->transformarDatos($resultado);

            PerformanceProfiler::end('MiServicio::procesarDatos');
            return $resultado;

        } catch (\Exception $e) {
            PerformanceProfiler::end('MiServicio::procesarDatos');
            throw $e;
        }
    }
}
```

## Funcionamiento Interno

### Ciclo de Medici√≥n

1. **Inicio**: `PerformanceProfiler::start()` registra timestamp inicial
2. **Ejecuci√≥n**: El c√≥digo se ejecuta normalmente
3. **Fin**: `PerformanceProfiler::end()` calcula duraci√≥n y registra medici√≥n
4. **Logging**: Se escribe autom√°ticamente al `debug.log`
5. **Resumen**: Al finalizar la petici√≥n, se muestra resumen global

### Datos Registrados

Por cada medici√≥n se captura:
- **Etiqueta**: Identificador √∫nico de la funci√≥n/componente
- **Tipo**: Categorizaci√≥n (service, manager, handler, renderer, etc.)
- **Tiempo**: Duraci√≥n en segundos con microsegundos
- **Memoria**: Uso m√°ximo de memoria durante la ejecuci√≥n
- **Llamadas**: N√∫mero de veces que se ejecut√≥ la misma funci√≥n

### Formato de Log

```
[Glory Profiler] MiServicio::procesarDatos | 0.045612s | 8.45 MB | 1 llamadas | service
[Glory Profiler] render_template_part | 0.012345s | 2.10 MB | 3 llamadas | renderer
```

## Resumen Final

### Estad√≠sticas Globales

Al finalizar cada petici√≥n, se muestra un resumen completo:

```
=== Glory Performance Profiler - RESUMEN FINAL ===
Total componentes medidos: 15
Tiempo total Glory: 1.234567 segundos
Memoria m√°xima: 12.45 MB
```

### Top 3 M√°s Lentos

```
TOP 3 componentes m√°s lentos:
  MiServicio::procesarDatos       | 0.0456s (37.0%)
  render_template_part            | 0.0234s (19.0%)
  consultar_base_datos            | 0.0189s (15.3%)
```

## Tipos de Componentes

El profiler clasifica autom√°ticamente los componentes por tipo basado en la etiqueta:

- **service**: Servicios de negocio (`*Service`)
- **manager**: Managers del framework (`*Manager`)
- **handler**: Handlers de AJAX/requests (`*Handler`)
- **controller**: Controladores (`*Controller`)
- **renderer**: Componentes de renderizado (`*Renderer`)
- **general**: Tipo por defecto

## Profiling de HTTP

### Medici√≥n Autom√°tica de Peticiones HTTP

El profiler intercepta autom√°ticamente todas las peticiones HTTP realizadas por WordPress:

```php
// Se registra autom√°ticamente en init()
add_filter('pre_http_request', [self::class, 'httpRequestStart'], 10, 3);
add_filter('http_response', [self::class, 'httpRequestEnd'], 10, 3);
```

### Log de Peticiones HTTP

```
[Glory Profiler][HTTP] GET https://api.wordpress.org/plugins/info/1.0/ | 0.234s | code=200 | timeout=5
[Glory Profiler][HTTP] POST https://mi-api.com/webhook | 1.567s | code=201 | timeout=10
```

## Wall Time Total

### Medici√≥n de Petici√≥n Completa

```php
// Se mide autom√°ticamente desde el inicio de la petici√≥n
private static float $requestStart = microtime(true);

// Se loguea al final
PerformanceProfiler::logWallTime();
// Output: [Glory Profiler] TOTAL REQUEST | 2.345678s | 15.67 MB
```

## M√©todos de la API

### `init()`
Inicializa el profiler y registra todos los hooks necesarios.

```php
public static function init(): void
```

### `start(string $etiqueta, string $tipo = 'general')`
Inicia la medici√≥n de una funci√≥n o componente.

```php
public static function start(string $etiqueta, string $tipo = 'general'): void
```

### `end(string $etiqueta)`
Finaliza la medici√≥n y registra los resultados.

```php
public static function end(string $etiqueta): void
```

### `medirFuncion(callable $funcion, string $etiqueta, string $tipo = 'general')`
M√©todo conveniente para medir funciones completas.

```php
public static function medirFuncion(callable $funcion, string $etiqueta, string $tipo = 'general')
```

### `obtenerMediciones()`
Retorna todas las mediciones realizadas.

```php
public static function obtenerMediciones(): array
```

### `obtenerResumen()`
Retorna mediciones ordenadas por tiempo de ejecuci√≥n.

```php
public static function obtenerResumen(): array
```

### `estaActivo()`
Verifica si el profiler est√° activo.

```php
public static function estaActivo(): bool
```

## Casos de Uso

### Optimizaci√≥n de Servicios

```php
class BusquedaService
{
    public function buscar($query)
    {
        PerformanceProfiler::start('BusquedaService::buscar', 'service');

        $resultados = $this->consultarBaseDatos($query);
        $resultados = $this->filtrarResultados($resultados);
        $resultados = $this->ordenarResultados($resultados);

        PerformanceProfiler::end('BusquedaService::buscar');
        return $resultados;
    }
}
```

### Identificaci√≥n de Cuellos de Botella

```php
// Despu√©s de ejecutar una p√°gina problem√°tica, revisar debug.log
// Buscar l√≠neas con [Glory Profiler] para identificar funciones lentas

// Ejemplo de output que indica problemas:
[Glory Profiler] consultar_api_externa | 5.678901s | 45.67 MB | 1 llamadas | service
[Glory Profiler] procesar_imagenes    | 2.345678s | 23.45 MB | 5 llamadas | renderer
```

### Monitoreo de Managers

```php
class ContenidoManager
{
    public function obtenerContenido($tipo, $id)
    {
        return PerformanceProfiler::medirFuncion(function() use ($tipo, $id) {
            // L√≥gica compleja aqu√≠
            return $this->procesarContenido($tipo, $id);
        }, 'ContenidoManager::obtenerContenido', 'manager');
    }
}
```

## Consideraciones de Rendimiento

### Overhead M√≠nimo

- **Condicionales eficientes**: Todas las mediciones est√°n detr√°s de `if (!self::$isActive)`
- **Logging as√≠ncrono**: No bloquea la ejecuci√≥n principal
- **Sin memoria extra**: Solo almacena datos necesarios para el resumen

### Optimizaciones Incluidas

- **Exclusi√≥n autom√°tica**: Se desactiva en AJAX, REST API y cron jobs
- **Prevenci√≥n de recursi√≥n**: Los m√©todos del profiler no se miden a s√≠ mismos
- **Limpieza autom√°tica**: Se reinician las mediciones entre peticiones

## Integraci√≥n con Glory Framework

### GloryLogger

El PerformanceProfiler est√° completamente integrado con GloryLogger para logging consistente.

### GloryFeatures

Se controla mediante el sistema de features para activaci√≥n granular.

### AssetManager

No requiere assets adicionales, funciona completamente en PHP.

## Soluci√≥n de Problemas

### Mediciones no aparecen

**Posibles causas:**
- Profiler no est√° activo (`estaActivo()` retorna `false`)
- Modo producci√≥n y opci√≥n desactivada
- Logging de WordPress desactivado

**Soluci√≥n:**
```php
// Verificar estado
if (PerformanceProfiler::estaActivo()) {
    // Forzar medici√≥n para testing
    PerformanceProfiler::start('test');
    sleep(1);
    PerformanceProfiler::end('test');
}
```

### Mediciones duplicadas

**Problema:** Aparecen m√∫ltiples entradas para la misma funci√≥n
**Causa:** La funci√≥n se ejecuta m√∫ltiples veces en la misma petici√≥n
**Soluci√≥n:** Es comportamiento esperado, el profiler acumula mediciones

### Memoria alta reportada

**Problema:** Uso de memoria muy alto en mediciones
**Causa:** Se mide el pico m√°ximo, no solo el usado por la funci√≥n
**Soluci√≥n:** Normal, indica el estado de memoria en ese punto de ejecuci√≥n

## Mejores Pr√°cticas

### Nomenclatura Consistente

```php
// ‚úÖ Bueno: Clase::metodo
PerformanceProfiler::start('UsuarioService::autenticar', 'service');

// ‚úÖ Bueno: funcion_descriptiva
PerformanceProfiler::start('procesar_pedido_completo', 'general');

// ‚ùå Evitar: nombres gen√©ricos
PerformanceProfiler::start('funcion', 'general');
```

### √Åmbito Apropiado

```php
// ‚úÖ Medir operaciones completas
PerformanceProfiler::start('crearUsuario');
// ... l√≥gica completa de creaci√≥n ...
PerformanceProfiler::end('crearUsuario');

// ‚úÖ Usar medirFuncion para funciones puras
$resultado = PerformanceProfiler::medirFuncion(
    fn() => $this->calcularTotal($items),
    'calcularTotal',
    'service'
);
```

### No medir todo

```php
// ‚ùå No medir funciones triviales
PerformanceProfiler::start('strlen'); // Overhead > funci√≥n
strlen('hola');
PerformanceProfiler::end('strlen');

// ‚úÖ Medir operaciones complejas
PerformanceProfiler::start('procesarImagen'); // Operaci√≥n compleja
$this->redimensionar($imagen);
$this->optimizar($imagen);
PerformanceProfiler::end('procesarImagen');
```

<Aside type="caution">
‚ö†Ô∏è **Importante**: El PerformanceProfiler solo debe activarse en entornos de desarrollo. En producci√≥n, el overhead de medici√≥n puede afectar el rendimiento.
</Aside>

<Aside type="tip">
üí° **Tip**: Usa el resumen final del profiler para identificar los componentes que m√°s tiempo consumen y priorizar optimizaciones.
</Aside>
